"""Validation Module for WPGen.

This module provides comprehensive validation with automatic fallback to safe
templates when validation fails. The validator ensures that all generated code is:
- Syntactically valid (PHP, HTML, CSS, JS)
- Structurally correct (balanced tags, proper nesting)
- WordPress-compliant (correct functions, hooks, template hierarchy)
- Safe (no forbidden patterns, no hallucinated functions)

When validation fails, the system automatically falls back to tested, safe templates
instead of generating broken themes.
"""

import subprocess
import tempfile
import re
from pathlib import Path
from typing import Tuple, List, Dict, Optional, Any
from dataclasses import dataclass

from .sanitizers import sanitize_file_complete
from .template_contracts import validate_template, get_contract, repair_template
from ..utils.logger import get_logger

logger = get_logger(__name__)


@dataclass
class ValidationResult:
    """Result of validation for a single file."""

    filename: str
    is_valid: bool
    errors: List[str]
    warnings: List[str]
    fixes_applied: List[str]
    used_fallback: bool


# Hallucinated WordPress functions (commonly generated by LLMs but don't exist)
HALLUCINATED_FUNCTIONS = {
    'post_loop', 'render_post', 'display_post', 'show_content',
    'is_on_sale', 'get_price_html', 'add_to_cart_url',
    'get_product_price', 'display_product', 'render_product',
    'woocommerce_product_loop',
}

# Real WordPress core functions (whitelist)
WORDPRESS_CORE_FUNCTIONS = {
    # Template tags
    'wp_head', 'wp_footer', 'body_class', 'post_class', 'get_header',
    'get_footer', 'get_sidebar', 'get_template_part', 'bloginfo',
    'get_bloginfo', 'wp_title', 'the_title', 'the_content', 'the_excerpt',
    'the_permalink', 'the_post_thumbnail', 'the_ID', 'the_author',
    'the_date', 'get_the_date', 'the_time', 'get_the_time',
    'the_category', 'the_tags', 'the_archive_title', 'the_archive_description',
    # Loop functions
    'have_posts', 'the_post', 'rewind_posts', 'wp_reset_postdata', 'wp_reset_query',
    # Conditional tags
    'is_home', 'is_front_page', 'is_single', 'is_page', 'is_archive',
    'is_category', 'is_tag', 'is_404', 'is_search', 'is_singular',
    'is_active_sidebar', 'has_post_thumbnail', 'comments_open',
    # Navigation
    'wp_nav_menu', 'the_posts_navigation', 'the_posts_pagination',
    'get_search_form', 'paginate_links',
    # Comments
    'comments_template', 'comment_form', 'wp_list_comments',
    # Widgets
    'dynamic_sidebar', 'register_sidebar',
    # Custom logo
    'the_custom_logo', 'get_custom_logo', 'has_custom_logo',
    # Theme support
    'add_theme_support', 'register_nav_menus',
    # Enqueue
    'wp_enqueue_style', 'wp_enqueue_script', 'get_stylesheet_uri',
    'get_template_directory_uri', 'get_template_directory',
    # Security/escaping
    'esc_html', 'esc_attr', 'esc_url', 'esc_js', 'esc_html__',
    'esc_attr__', 'esc_html_e', 'esc_attr_e', 'wp_kses_post',
    'sanitize_text_field',
    # Translation
    '__', '_e', '_x', '_ex', '_n', '_nx',
    # Common
    'wp_get_theme', 'get_option', 'get_theme_mod', 'wp_body_open',
    'language_attributes',
}


class ThemeValidator:
    """Comprehensive theme validator with automatic fallback to safe templates."""

    def __init__(self, php_path: str = 'php', enable_fallback: bool = True):
        """Initialize theme validator.

        Args:
            php_path: Path to PHP binary for syntax validation
            enable_fallback: Whether to automatically use fallback templates on failure
        """
        self.php_path = php_path
        self.enable_fallback = enable_fallback
        self.php_available = self._check_php_available()

    def _check_php_available(self) -> bool:
        """Check if PHP CLI is available for syntax validation.

        Returns:
            True if PHP is available, False otherwise
        """
        try:
            result = subprocess.run(
                [self.php_path, '--version'],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0:
                logger.debug(f"PHP is available: {result.stdout.splitlines()[0]}")
                return True
            return False
        except (FileNotFoundError, subprocess.TimeoutExpired):
            logger.warning(f"PHP CLI not available at '{self.php_path}'")
            return False

    def validate_php_syntax(self, code: str, filename: str) -> Tuple[bool, Optional[str]]:
        """Validate PHP syntax using PHP CLI or Python-based fallback.

        Args:
            code: PHP code to validate
            filename: Filename for error reporting

        Returns:
            Tuple of (is_valid, error_message)
        """
        if not self.php_available:
            logger.debug(f"PHP CLI not available, using Python validation for {filename}")
            return self._python_php_validation(code, filename)

        # Write code to temporary file and validate with php -l
        try:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.php', delete=False) as f:
                f.write(code)
                temp_path = f.name

            result = subprocess.run(
                [self.php_path, '-l', temp_path],
                capture_output=True,
                text=True,
                timeout=10
            )

            Path(temp_path).unlink()

            if result.returncode == 0:
                return True, None
            else:
                error_msg = result.stderr or result.stdout
                # Clean up error message
                error_msg = error_msg.replace(temp_path, filename)
                return False, error_msg

        except Exception as e:
            logger.warning(f"PHP syntax validation failed for {filename}: {e}")
            return self._python_php_validation(code, filename)

    def _python_php_validation(self, code: str, filename: str) -> Tuple[bool, Optional[str]]:
        """Python-based PHP validation when PHP CLI is unavailable.

        Args:
            code: PHP code to validate
            filename: Filename for error reporting

        Returns:
            Tuple of (is_valid, error_message)
        """
        errors = []

        # Check for basic PHP structure
        if '<?php' not in code and '<!DOCTYPE' not in code and '<html' not in code:
            errors.append("Missing <?php opening tag")

        # Check for brace matching
        open_braces = code.count('{')
        close_braces = code.count('}')
        if open_braces != close_braces:
            errors.append(f"Mismatched braces: {open_braces} opening, {close_braces} closing")

        # Check for common syntax errors
        if re.search(r'<\?php\s*;', code):
            errors.append("Empty PHP block with semicolon")

        if re.search(r'\b(if|while|foreach|for)\s*\([^)]+\)\s*;', code):
            errors.append("Stray semicolon after control structure")

        if errors:
            return False, '; '.join(errors)

        return True, None

    def validate_wordpress_functions(
        self,
        code: str,
        filename: str
    ) -> Tuple[List[str], List[str]]:
        """Validate that code only uses real WordPress functions.

        Args:
            code: PHP code to validate
            filename: Filename for reporting

        Returns:
            Tuple of (hallucinated_functions, warnings)
        """
        hallucinated = []
        warnings = []

        # Find all function calls
        function_pattern = r'([a-z_][a-z0-9_]*)\s*\('
        functions = re.findall(function_pattern, code, re.IGNORECASE)

        for func in set(functions):
            # Check if hallucinated
            if func in HALLUCINATED_FUNCTIONS:
                hallucinated.append(func)
                logger.error(f"Found hallucinated function: {func}() in {filename}")

            # Check if looks like WordPress but isn't in whitelist
            elif func.startswith(('wp_', 'get_', 'the_', 'is_', 'has_', 'add_', 'register_')):
                if func not in WORDPRESS_CORE_FUNCTIONS:
                    warnings.append(f"Unknown WordPress-like function: {func}() in {filename}")

        return hallucinated, warnings

    def check_forbidden_patterns(self, code: str, filename: str) -> List[str]:
        """Check for forbidden patterns that should never appear in theme files.

        Args:
            code: Code to check
            filename: Filename for reporting

        Returns:
            List of forbidden patterns found
        """
        violations = []

        # Forbidden debug directives
        debug_patterns = [
            ("define('WP_DEBUG'", "WP_DEBUG definition (belongs in wp-config.php)"),
            ('define("WP_DEBUG"', "WP_DEBUG definition (belongs in wp-config.php)"),
            ("ini_set('display_errors'", "ini_set display_errors (belongs in wp-config.php)"),
            ('error_reporting(', "error_reporting() call (belongs in wp-config.php)"),
        ]

        for pattern, description in debug_patterns:
            if pattern in code:
                violations.append(f"Forbidden pattern: {description}")

        # Check for eval() or other dangerous functions
        if 'eval(' in code:
            violations.append("Dangerous function: eval()")

        # Check for shell execution
        if any(func in code for func in ['exec(', 'shell_exec(', 'system(', 'passthru(']):
            violations.append("Shell execution functions are forbidden")

        return violations

    def validate_file_complete(
        self,
        content: str,
        filename: str,
        fallback_content: str
    ) -> ValidationResult:
        """Complete validation pipeline with automatic fallback.

        This is the main entry point for validation. It:
        1. Sanitizes the content
        2. Validates against template contract
        3. Validates PHP syntax
        4. Checks for forbidden patterns and hallucinated functions
        5. Falls back to safe template if any validation fails

        Args:
            content: Generated file content
            filename: Filename (e.g., 'header.php')
            fallback_content: Safe fallback template to use if validation fails

        Returns:
            ValidationResult with final content and validation details
        """
        errors = []
        warnings = []
        fixes_applied = []
        used_fallback = False

        # Determine file type
        file_type = 'php' if filename.endswith('.php') else 'other'

        # Step 1: Sanitize
        logger.debug(f"Sanitizing {filename}...")
        sanitized, sanitize_fixes = sanitize_file_complete(content, file_type)

        # Record sanitization fixes
        for category, category_fixes in sanitize_fixes.items():
            if category_fixes:
                fixes_applied.extend(category_fixes)
                logger.debug(f"{filename}: {category}: {len(category_fixes)} fix(es)")

        current_content = sanitized

        # Step 2: Template contract validation
        if file_type == 'php':
            logger.debug(f"Validating template contract for {filename}...")
            contract = get_contract(filename)

            if contract:
                is_valid, violations = validate_template(filename, current_content)

                if not is_valid:
                    # Try to repair
                    logger.warning(f"{filename} violates template contract. Attempting repair...")
                    repaired, repairs = repair_template(filename, current_content)

                    if repairs:
                        fixes_applied.extend(repairs)
                        current_content = repaired

                        # Re-validate
                        is_valid, violations = validate_template(filename, current_content)

                    if not is_valid:
                        errors.extend(violations)
                        logger.error(f"{filename} failed contract validation after repair")

                        if self.enable_fallback:
                            logger.warning(f"Using safe fallback template for {filename}")
                            current_content = fallback_content
                            used_fallback = True

        # Step 3: PHP syntax validation
        if file_type == 'php' and not used_fallback:
            logger.debug(f"Validating PHP syntax for {filename}...")
            syntax_valid, syntax_error = self.validate_php_syntax(current_content, filename)

            if not syntax_valid:
                errors.append(f"PHP syntax error: {syntax_error}")

                if self.enable_fallback:
                    logger.error(f"{filename} has PHP syntax errors, using fallback")
                    current_content = fallback_content
                    used_fallback = True

        # Step 4: Check for hallucinated functions
        if file_type == 'php' and not used_fallback:
            logger.debug(f"Checking WordPress functions in {filename}...")
            hallucinated, func_warnings = self.validate_wordpress_functions(
                current_content,
                filename
            )

            if hallucinated:
                errors.append(f"Contains hallucinated functions: {', '.join(hallucinated)}")

                if self.enable_fallback:
                    logger.error(f"{filename} contains hallucinated functions, using fallback")
                    current_content = fallback_content
                    used_fallback = True

            warnings.extend(func_warnings)

        # Step 5: Check for forbidden patterns
        if file_type == 'php' and not used_fallback:
            logger.debug(f"Checking forbidden patterns in {filename}...")
            forbidden = self.check_forbidden_patterns(current_content, filename)

            if forbidden:
                errors.extend(forbidden)

                if self.enable_fallback:
                    logger.error(f"{filename} contains forbidden patterns, using fallback")
                    current_content = fallback_content
                    used_fallback = True

        # Build result
        is_valid = len(errors) == 0

        if is_valid:
            logger.info(f"✓ {filename} passed validation")
        elif used_fallback:
            logger.warning(f"⚠ {filename} used fallback template due to validation failures")
        else:
            logger.error(f"✗ {filename} failed validation with {len(errors)} error(s)")

        return ValidationResult(
            filename=filename,
            is_valid=is_valid or used_fallback,
            errors=errors,
            warnings=warnings,
            fixes_applied=fixes_applied,
            used_fallback=used_fallback
        )

    def validate_theme_complete(
        self,
        theme_files: Dict[str, str],
        fallback_templates: Dict[str, str]
    ) -> Tuple[Dict[str, str], List[ValidationResult]]:
        """Validate an entire theme and return validated files with fallbacks applied.

        Args:
            theme_files: Dictionary mapping filenames to content
            fallback_templates: Dictionary mapping filenames to safe fallback content

        Returns:
            Tuple of (validated_files, list_of_validation_results)
        """
        validated_files = {}
        results = []

        for filename, content in theme_files.items():
            fallback = fallback_templates.get(filename, content)

            result = self.validate_file_complete(content, filename, fallback)
            results.append(result)

            # Use the final validated content (may be original, sanitized, or fallback)
            if result.used_fallback:
                validated_files[filename] = fallback
            else:
                # Use sanitized version
                sanitized, _ = sanitize_file_complete(content)
                validated_files[filename] = sanitized

        # Log summary
        total = len(results)
        valid = sum(1 for r in results if r.is_valid)
        fallback_count = sum(1 for r in results if r.used_fallback)

        logger.info(f"Theme validation complete: {valid}/{total} files valid, {fallback_count} used fallbacks")

        return validated_files, results


def validate_and_get_safe_content(
    content: str,
    filename: str,
    fallback_content: str,
    enable_fallback: bool = True
) -> Tuple[str, ValidationResult]:
    """Convenience function to validate a single file and get safe content.

    Args:
        content: Generated content
        filename: Filename
        fallback_content: Safe fallback template
        enable_fallback: Whether to use fallback on failure

    Returns:
        Tuple of (safe_content, validation_result)
    """
    validator = ThemeValidator(enable_fallback=enable_fallback)
    result = validator.validate_file_complete(content, filename, fallback_content)

    if result.used_fallback:
        return fallback_content, result
    else:
        # Return sanitized version
        sanitized, _ = sanitize_file_complete(content)
        return sanitized, result
