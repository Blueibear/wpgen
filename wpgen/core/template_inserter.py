"""Template Inserter Module for WPGen.

This module provides safe methods to insert LLM-generated content into
boilerplate templates. All insertions are validated and sanitized to prevent
breaking the template structure.

The key principle is: boilerplate provides structure, LLM provides styling/content.
LLM-generated code is inserted into predetermined safe zones.
"""

from typing import Dict, Any, Optional, List
from .sanitizers import sanitize_file_complete
from ..utils.logger import get_logger

logger = get_logger(__name__)


class SafeTemplateInserter:
    """Safely inserts content into template structures."""

    def __init__(self):
        """Initialize template inserter."""
        pass

    def insert_css_into_style(
        self,
        header: str,
        llm_generated_css: str
    ) -> str:
        """Insert LLM-generated CSS into style.css with header.

        Args:
            header: WordPress theme header comment
            llm_generated_css: CSS generated by LLM

        Returns:
            Complete style.css content
        """
        # Sanitize CSS
        sanitized_css, fixes = sanitize_file_complete(llm_generated_css, 'css')

        if fixes:
            logger.info(f"Sanitized CSS with {sum(len(f) for f in fixes.values())} fixes")

        # Ensure header ends with newline
        if not header.endswith('\n'):
            header += '\n'

        # Combine header and CSS
        complete_style = header + '\n' + sanitized_css

        return complete_style

    def insert_custom_functions(
        self,
        base_functions_php: str,
        llm_generated_functions: str,
        theme_slug: str
    ) -> str:
        """Insert LLM-generated custom functions into functions.php base.

        The base provides required WordPress hooks. LLM-generated functions
        are appended at the end, after validation.

        Args:
            base_functions_php: Base functions.php with required hooks
            llm_generated_functions: Additional functions from LLM
            theme_slug: Theme slug for validation

        Returns:
            Complete functions.php content
        """
        # Sanitize LLM functions
        sanitized, fixes = sanitize_file_complete(llm_generated_functions, 'php')

        if fixes:
            logger.info(f"Sanitized custom functions with {sum(len(f) for f in fixes.values())} fixes")

        # Extract only the additional function definitions
        # Skip duplicate theme setup if present
        cleaned_additions = self._extract_safe_additions(
            sanitized,
            base_functions_php,
            theme_slug
        )

        if not cleaned_additions:
            # No safe additions found, return base only
            logger.warning("No safe custom functions extracted from LLM output")
            return base_functions_php

        # Append to base
        if not base_functions_php.rstrip().endswith('\n'):
            base_functions_php += '\n'

        complete_functions = base_functions_php + '\n' + cleaned_additions

        return complete_functions

    def _extract_safe_additions(
        self,
        llm_output: str,
        base_code: str,
        theme_slug: str
    ) -> str:
        """Extract safe function additions from LLM output.

        This removes duplicates of what's already in base and extracts
        only new, safe function definitions.

        Args:
            llm_output: LLM-generated code
            base_code: Base code already present
            theme_slug: Theme slug

        Returns:
            Safe additional code to append
        """
        additions = []

        # Split LLM output into lines
        lines = llm_output.split('\n')

        in_function = False
        current_function = []

        for line in lines:
            # Detect function start
            if 'function ' in line and '{' in line:
                in_function = True
                current_function = [line]
            elif in_function:
                current_function.append(line)
                # Detect function end
                if '}' in line:
                    func_code = '\n'.join(current_function)
                    # Check if this function already exists in base
                    func_name = self._extract_function_name(func_code)
                    if func_name and func_name not in base_code:
                        # This is a new function, keep it
                        additions.append(func_code)
                    in_function = False
                    current_function = []

        return '\n\n'.join(additions)

    def _extract_function_name(self, func_code: str) -> Optional[str]:
        """Extract function name from function definition.

        Args:
            func_code: Function code

        Returns:
            Function name or None
        """
        import re
        match = re.search(r'function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(', func_code)
        if match:
            return match.group(1)
        return None

    def wrap_content_in_template(
        self,
        content_html: str,
        wrapper_class: str = 'content-wrapper'
    ) -> str:
        """Wrap HTML content in a proper container.

        Args:
            content_html: HTML content
            wrapper_class: CSS class for wrapper

        Returns:
            Wrapped HTML
        """
        return f'''<div class="{wrapper_class}">
    {content_html}
</div>'''

    def merge_template_sections(
        self,
        sections: Dict[str, str],
        template_structure: str,
        markers: Dict[str, str]
    ) -> str:
        """Merge multiple LLM-generated sections into a template structure.

        Args:
            sections: Dictionary mapping section names to content
            template_structure: Base template with markers
            markers: Dictionary mapping section names to marker strings

        Returns:
            Complete template with sections inserted

        Example:
            sections = {'hero': '<div>Hero</div>'}
            template_structure = "<!-- HERO_MARKER -->\\n<!-- CONTENT_MARKER -->"
            markers = {'hero': '<!-- HERO_MARKER -->'}
            Result: "<div>Hero</div>\\n<!-- CONTENT_MARKER -->"
        """
        result = template_structure

        for section_name, content in sections.items():
            marker = markers.get(section_name)
            if marker and marker in result:
                # Sanitize content
                sanitized, _ = sanitize_file_complete(content)
                result = result.replace(marker, sanitized)
            else:
                logger.warning(f"Marker for section '{section_name}' not found in template")

        return result


def insert_llm_content_safe(
    template_type: str,
    base_template: str,
    llm_content: str,
    context: Dict[str, Any]
) -> str:
    """Safely insert LLM content into a base template.

    This is the main entry point for template insertion.

    Args:
        template_type: Type of template (functions, style, etc.)
        base_template: Base template structure
        llm_content: LLM-generated content
        context: Context dictionary with theme info

    Returns:
        Complete template with safe content insertion
    """
    inserter = SafeTemplateInserter()
    theme_slug = context.get('theme_slug', 'wpgen-theme')

    if template_type == 'style':
        # Insert CSS into style.css
        header = context.get('style_header', '')
        return inserter.insert_css_into_style(header, llm_content)

    elif template_type == 'functions':
        # Insert custom functions into functions.php
        return inserter.insert_custom_functions(base_template, llm_content, theme_slug)

    else:
        # For other templates, just sanitize and return
        sanitized, fixes = sanitize_file_complete(llm_content)

        if fixes:
            total_fixes = sum(len(f) for f in fixes.values())
            logger.info(f"Sanitized {template_type} with {total_fixes} fixes")

        return sanitized
